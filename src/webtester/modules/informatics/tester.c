/*
 *
 * ================================================================================
 *  tester.c - part of the WebTester Server
 * ================================================================================
 *
 *  Written (by Nazgul) under General Public License.
 *
*/

#include "informatics.h"
#include "macros.h"

#include <libwebtester/smartinclude.h>
#include <libwebtester/dynastruc.h>
#include <libwebtester/conf.h>
#include <libwebtester/flexval.h>
#include <libwebtester/strlib.h>
#include <libwebtester/regexp.h>
#include <libwebtester/util.h>
#include <libwebtester/fs.h>
#include <libwebtester/mutex.h>

#include <librun/run.h>

#include <testlib/testlib.h>

//#include <glib.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>

////
//

// MAX count of tests
#define MAX_TESTS      1024
#define MAX_ERRCODE    2

#define MAX_COMPILER_MSG_LEN 4096

////////////////////////////////////////
// Macroses

// Crash in testing loop
#define LOOPCRASH \
  (*__points)=0; \
  strcpy (__errors, "CR"); \
  CR=TRUE; \
  goto __done_;

// Push error of current test
#define ERR(__err, __s) \
  { \
    __err=TRUE; \
    strcpy (cur_err_str, __s); \
    push_string (__s, " ", tests_res_pchar); \
    /* If rules are ACM we needn't run solution in next tests */ \
    if (acm) { \
      unlink (full_input); \
      unlink (full_output); \
      LOG_TEST; \
      goto __done_; \
    } \
  }

// Log result of currebt test
#define LOG_TEST \
  TASK_LOG (*__self, "  Test #%d: %s\n", i+1, cur_err_str);

// Check module's active in testing loop
#define LOOP_CHECK_ACTIVE \
  if (mutex_trylock (active)) \
    { \
      mutex_unlock (active); \
      goto __done_; \
    }

// Check module's active after testing loop
#define LOOP_DONE_CHECK_ACTIVE \
  if (mutex_trylock (active)) \
    { \
      mutex_unlock (active); \
      /* Checking has been interrupted. */ \
      /* So there is nothing interesting in testing dir. */ \
      unlinkdir (__cur_testing_dir); \
      return; \
    }

// Check module's active in main testing thread
#define TESTING_CHECK_ACTIVE \
  if (mutex_trylock (active)) \
    { \
      mutex_unlock (active); \
      goto __free_; \
    }

#ifdef INFORMATICS_ENABLE_REPORT
#  define REPORT(__params,__text,__args...) \
  { \
    char sbuf[4096], buf[4096]; \
    sprintf (buf, __text, ##__args); \
    strcpy (sbuf, ""); \
    if (assarr_get_value (__params, "REPORT")) \
      { \
        strcat (sbuf, assarr_get_value (__params, "REPORT")); \
        assarr_unset_value (__params, "REPORT", assarr_deleter_free_ref_data); \
      } \
    strcat (sbuf, buf); \
    assarr_set_value (__params, "REPORT", strdup (sbuf)); \
  }
#else
#  define REPORT(__params,__text,__args...)
#endif

#define TASK_SRCEXT(__self) \
  COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self), "Extension", INFORMATICS_SRCEXT)

////////
//

static char log_banner[]="\
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\
 This file is automatically generated by module Informatics\n\
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n";

////////
//

static DWORD        checker_memory_limit = INFORMATICS_CHECKER_RSS_LIMIT;
static DWORD        checker_time_limit   = INFORMATICS_CHECKER_TIME_LIMIT*USEC_COUNT;
static GThreadPool  *pool       = NULL;
static GMutex       *active     = NULL;
static long         max_threads = INFORMATICS_MAX_THREADS;

static char testing_dir[4096];
static char data_dir[4096];
static char problems_dir[4096];
static char source_file[4096];
static char file_to_exec[4096];

static char checker_cmd_template[4096];

static DWORD unlink_interval     = INFORMATICS_UNLINK_INTERVAL*USEC_COUNT;
static long  keep_alive_testdirs = INFORMATICS_KEEP_ALIVE_TESTDIRS;
static GMutex *unlink_mutex = NULL;

// Extensions of input and output tests' filenames
static char tst_ext[128];
static char ans_ext[128];

static long solution_exec_uid=-1;
static long solution_exec_gid=-1;
static char solution_exec_user[4096]="";
static char solution_exec_group[4096]="";

static BOOL use_chroot=FALSE;

static mutex_t suspended=0;

// Null-terminated list of required input task's params
static char *required_params[]=
  { "SOURCE",
    "COMPILERID",
    "BONUS",
    "INPUTFILE",
    "OUTPUTFILE",
    "MEMORYLIMIT",
    "TIMELIMIT",
    "ACM",
    "TESTS",
    0
  };

static char chroot_items[64][64]={{0}};

///////////////////////////////////
// Internal stuff

static void
copy_chroot_data                   (char *__dst_dir)
{
  char src_dir[4096];
  static char init=FALSE;

  INF_DEBUG_LOG ("Copying chroot data to %s\n", __dst_dir);

  sprintf (src_dir, "%s/chroot", data_dir);
  fcopydir (src_dir, __dst_dir);
  
  sprintf (src_dir, "%s/chroot", data_dir);

  if (!init)
    {
      // Cache list of items, needed by chrooting
      dynastruc_t *ls;
      int count=0;
      char *cur_dir;
      ls=dir_listing (src_dir);

      DYNA_FOREACH (ls, cur_dir);
        strcpy (chroot_items[count++], cur_dir);
      DYNA_DONE;

      dyna_destroy (ls, dyna_deleter_free_ref_data);
      init=TRUE;
    }
}

static void
remove_chroot_data                 (char *__dir)
{
  int i=0;
  char full[4096];

  INF_DEBUG_LOG ("Removing chroot data from %s\n", __dir);

  while (chroot_items[i][0])
    {
      sprintf (full, "%s/%s", __dir, chroot_items[i]);
      unlinkdir (full);
      i++;
    }
}

////////////////////////////////////////
// Different stuff

static void
push_string                        (char *__item, char *__delimeter, char *__buf)
{
  if (strcmp (__buf, "")) strcat (__buf, __delimeter);
  strcat (__buf, __item);
}

static void     // Replace default variables in string
replace_defaults                   (char *__str, char *__cur_testing_dir, char *__cur_data_dir)
{
  REPLACE_VAR (__str, "testing_dir",      testing_dir);
  REPLACE_VAR (__str, "data_dir",         data_dir);
  REPLACE_VAR (__str, "cur_testing_dir",  __cur_testing_dir);
  REPLACE_VAR (__str, "cur_data_dir",     __cur_data_dir);
}

static void     // PChar-ed number of test
testnum                            (int __num, int __total, char *__buf)
{
  if (__total<100)
    sprintf (__buf, "%02d", __num); else
    sprintf (__buf, "%03d", __num);
}

////////////////////////////////////////
//

static BOOL     // Save solution to file
save_solution                      (wt_task_t *__self, char *__cur_testing_dir)
{
  char fn[4096];
  char *src=TASK_INPUT_PARAM (*__self, "SOURCE");

  sprintf (fn, "%s/%s%s", __cur_testing_dir, source_file, TASK_SRCEXT (__self));

  // Write data to stream
  if (fwritebuf (fn, src))
    {
      INF_DEBUG_LOG ("Task %ld. Error writting buffer to solution file\n", __self->sid);
      return FALSE;
    }

  chmod (fn, 00660);
  
  return TRUE;
}

////////////////////////////////////////
// Compiling stuff

static void     // Get command to compile solution
build_compiler_command             (wt_task_t *__self, char *__cur_testing_dir, char *__cur_data_dir, char *__cmd)
{
  char dummy[4096], flags[4096]="", flags_path[1024];
  // Get command from config file
  strcpy (__cmd, COMPILER_PCHAR_KEY (TASK_COMPILER_ID (*__self), "Command"));

  sprintf (flags_path, "CompilerFlags/%s", TASK_COMPILER_ID (*__self));
  INF_PCHAR_KEY (flags,  flags_path);

  ////////
  // Parse command
  replace_defaults (__cmd, __cur_testing_dir, __cur_data_dir);
  REPLACE_VAR (__cmd, "flags", flags);

  // Source filename
  sprintf (dummy, "%s%s", source_file, TASK_SRCEXT (__self));
  REPLACE_VAR (__cmd, "source", dummy);

  // Output filename
  sprintf (dummy, "%s%s", file_to_exec, COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self), "OutputExtension", INFORMATICS_EXECEXT));
  REPLACE_VAR (__cmd, "output", dummy);
}

static BOOL     // Run compiler with profiling
run_compiler                       (wt_task_t *__self, char *__cmd, char *__cur_testing_dir, char *__cur_data_dir, assarr_t *__params)
{
  DWORD compiler_ml, compiler_tl, common_compiler_ml, common_compiler_tl;
  run_process_info_t *proc;
  BOOL result=TRUE;

  ////
  // Get compiler's limits
  common_compiler_ml=COMPILER_SAFE_COMMON_INT_KEY   ("Limits/RSS",  INFORMATICS_COMPILER_RSS_LIMIT);
  common_compiler_tl=COMPILER_SAFE_COMMON_FLOAT_KEY ("Limits/Time", INFORMATICS_COMPILER_TIME_LIMIT);

  compiler_ml=COMPILER_SAFE_INT_KEY   (TASK_COMPILER_ID (*__self), "Limits/RSS", common_compiler_ml);
  compiler_tl=COMPILER_SAFE_FLOAT_KEY (TASK_COMPILER_ID (*__self), "Limits/Time", common_compiler_tl)*USEC_COUNT;

  // Create process

  INF_DEBUG_LOG ("Task %ld. Executing compiler (cmd: %s)\n", __self->sid, __cmd);
  proc=run_create_process (__cmd, __cur_testing_dir, compiler_ml, compiler_tl);
  run_execute_process (proc); // Execute process and..
  run_pwait (proc);           // ..wait finishing of process
  INF_DEBUG_LOG ("Task %ld. Finish executing compiler\n", __self->sid);

  if (RUN_PROC_EXEC_ERROR (*proc))
    {
      INF_DEBUG_LOG ("Task %ld. Executing compiler failed: %s\n", __self->sid, RUN_PROC_ERROR_DESC (*proc));
      TASK_LOG (*__self, "\n--------\nFatal error: error executing compiler: %s.\nTesting aborted.\n", RUN_PROC_ERROR_DESC (*proc));
      REPORT (__params, "Error executing compiler: %s.", RUN_PROC_ERROR_DESC (*proc));
      run_free_process (proc);
      return -1;
    }

  // Set output buffer from pipe
  if (RUN_PROC_PIPEBUF (*proc))
    {
      char *pchar=strdup (RUN_PROC_PIPEBUF (*proc));

      if (strlen (pchar)>MAX_COMPILER_MSG_LEN)
        {
          pchar[MAX_COMPILER_MSG_LEN-4]=0;
          strcat (pchar, "...");
        }
      assarr_set_value (__params, "COMPILER_MESSAGES", pchar);
    }

  // Nonzero-coded exit - compilation error
  if (PROCESS_RUNTIME_ERROR (*proc)) 
    result=FALSE;

  run_free_process (proc);

  return result;
}

static BOOL     // Checking, casted after running compiler
post_compiling_check               (wt_task_t *__self, char *__cur_testing_dir, char *__cur_data_dir, assarr_t *__params)
{
  char pchar[4096];

  ////////
  // Check for existment of solution executable file
  // Get full filename of executable file
  sprintf (pchar, "%s/%s%s", __cur_testing_dir, file_to_exec,
    COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self), "OutputExtension", ""));
  if (!fexists (pchar))
    return FALSE;

  chmod (pchar, 00775);

  return TRUE;
}

static BOOL     // Compilation of solutions
compile_solution                   (wt_task_t *__self, char *__cur_testing_dir, char *__cur_data_dir, assarr_t *__params)
{
  char cmd[32768];

  // Generate command
  strcpy (cmd, "");
  build_compiler_command (__self, __cur_testing_dir, __cur_data_dir, cmd);
  assarr_set_value (__params, "COMPILER_COMMAND", strdup (cmd));

  // Compile command not defined
  if (!strcmp (cmd, ""))
    {
      INF_DEBUG_LOG ("Task %ld. Compiler's command is undefined\n", __self->sid);
      TASK_LOG (*__self, "\n--------\nFatal error: Compiler command is undefined.\nTesting aborted.\n");
      REPORT (__params, "Compiler command is undefined.");
      return -1;
    }

  if (!run_compiler (__self, cmd, __cur_testing_dir, __cur_data_dir, __params))
    return FALSE;

  // Some more checking
  return post_compiling_check (__self, __cur_testing_dir, __cur_data_dir, __params);
}

////////////////////////////////////////
//

static BOOL     // Copy test to testing catalogue
copy_test                          (int __num, int __total, char *__data_dir, char *__dst, char *__name)
{
  char src[4096], dst[4096], tst[16];

  // Get full source filename
  testnum (__num, __total, tst);
  sprintf (src, "%s/%s%s", __data_dir, tst, tst_ext);

  if (!fexists (src)) // Check for existment of test file
    return FALSE;

  // Get full destination filename
  sprintf (dst, "%s/%s", __dst, __name);

  if (copyfile (src, dst))
    {
      INF_DEBUG_LOG ("Error copuing test file from %s to %s\n", src, dst);
      return FALSE;
    }
  
  return TRUE;
}

static void     // Build command to run checker
build_checker_cmd (wt_task_t *__self, char *__cur_testing_dir, char *__cur_data_dir,
        int __test_num, int __tests_count, char *__out)
{
  char atest[16];  // PChar-ed number of test
  char *input_file   = TASK_INPUT_PARAM (*__self, "INPUTFILE"); 
  char *output_file  = TASK_INPUT_PARAM (*__self, "OUTPUTFILE"); 

  testnum (__test_num, __tests_count, atest);

  strcpy (__out, checker_cmd_template);

  replace_defaults (__out, __cur_testing_dir, __cur_data_dir);

  REPLACE_VAR (__out, "test",         atest);
  REPLACE_VAR (__out, "input_file",   input_file);
  REPLACE_VAR (__out, "output_file",  output_file);
}

////////////////////////////////////////
//

static void     // Main stuff of testing
testing_main_loop                  (wt_task_t *__self,
                                    char      *__cur_data_dir,
                                    char      *__cur_testing_dir,
                                    int       *__points,
                                    char      *__errors,
                                    assarr_t  *__params)
{
  int i;

  INF_DEBUG_LOG ("Task %ld. Enter testing mainloop stuff\n", __self->sid);

  ////////
  // Bonus points (if all tests passed)
  int bonus=atoi (TASK_INPUT_PARAM (*__self, "BONUS"));

  ////////
  // I/O filenames 
  // Name of input file
  char *input_file   = TASK_INPUT_PARAM (*__self, "INPUTFILE");   
  // Name of output file
  char *output_file  = TASK_INPUT_PARAM (*__self, "OUTPUTFILE"); 

  ////////
  // Resource limits
  // But why simple atof doesn't work?
  DWORD memory_limit = flexval_atolf (TASK_INPUT_PARAM (*__self, "MEMORYLIMIT"))*1024;     // Kbytes
  DWORD time_limit   = flexval_atolf (TASK_INPUT_PARAM (*__self, "TIMELIMIT"))*USEC_COUNT; // usecs

  char full_input[4096],    // Full input filename
       full_output[4096],   // Full output filename
       checker_cmd[4096];   // Command to execute 

  char  // String with all tests' results
        tests_res_pchar[(MAX_ERRCODE+1)*MAX_TESTS]; 

  // Process's descriptor
  run_process_info_t *proc=NULL; 
  // Filename to execute
  char execfn[4096]={0};

  // Errors
  BOOL RE=FALSE, ML=FALSE, TL=FALSE, WA=FALSE, PE=FALSE, CR=FALSE;
  char cur_err_str[MAX_ERRCODE+1];  // PChar-ed error for current test
  BOOL acm=!strcmp (TASK_INPUT_PARAM (*__self, "ACM"), "TRUE");

  ////////
  // Unpack tests' data
  char *tests_pchar=TASK_INPUT_PARAM (*__self, "TESTS"), effective_tests[4096];
  char **tests_pchar_arr=0;
  int tests[MAX_TESTS];  // Points for tests

  trim (tests_pchar, effective_tests);
  int tests_count=explode (effective_tests, " ", &tests_pchar_arr);

  for (i=0; i<tests_count; i++)
    tests[i]=atoi (tests_pchar_arr[i]);

  // Free unwanted data
  free_explode_data (tests_pchar_arr);

  ////
  //

  // Some more initializations
  sprintf (full_input,    "%s/%s", __cur_testing_dir, input_file);
  sprintf (full_output,   "%s/%s", __cur_testing_dir, output_file);

  strcpy (tests_res_pchar, "");

  TASK_LOG (*__self, "----\n");

  INF_PCHAR_KEY (execfn,  "FileToExec");
  strcat (execfn, COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self), "OutputExtension", ""));

  // Copying all libs/binaries needed for correct running of solution
  if (use_chroot)
    copy_chroot_data (__cur_testing_dir);

  // Cycle by tests
  INF_DEBUG_LOG ("Task %ld. Begin cycle by tests\n", __self->sid);
  for (i=0; i<tests_count; i++)
    {
      LOOP_CHECK_ACTIVE;

      // Some pre-initialization
      strcpy (cur_err_str, "OK");
      // Command to execute checker
      build_checker_cmd (__self, __cur_testing_dir, __cur_data_dir, i+1, tests_count, checker_cmd);

      // Copy test file (input file)
      INF_DEBUG_LOG ("Task %ld. Copy test\n", __self->sid);
      if (!copy_test (i+1, tests_count, __cur_data_dir, __cur_testing_dir, input_file))
        {
          TASK_LOG (*__self, "\n--------\nFatal error: error copying test file #%d.\nTesting aborted.\n", i+1);
          REPORT (__params, "Error copying test #%d.", i+1);
          LOOPCRASH;
        }

      ////
      // Execute solution
      SAFE_FREE_PROC (proc);
      INF_DEBUG_LOG ("Task %ld. Executing solution (cmd: %s)\n", __self->sid, execfn);
      proc=run_create_process (execfn, __cur_testing_dir, memory_limit, time_limit);

      // Set security info
      run_set_usergroup (proc, solution_exec_uid, solution_exec_gid);
      run_set_chroot (proc, use_chroot);

      run_execute_process (proc);
      run_pwait (proc);
      INF_DEBUG_LOG ("Task %ld. Finish executing solution\n", __self->sid);

      LOOP_CHECK_ACTIVE;

      if (RUN_PROC_EXEC_ERROR (*proc))
        {
          INF_DEBUG_LOG ("Task %ld. Fatal error duting executing solution: %s\n", __self->sid, RUN_PROC_ERROR_DESC (*proc));
          TASK_LOG (*__self, "\n--------\nFatal error: error executing solution "
            "at test #%d: %s.\nTesting aborted.\n", i+1, RUN_PROC_ERROR_DESC (*proc));
          REPORT (__params, "Error executing solution at test #%d: %s.", i+1, RUN_PROC_ERROR_DESC (*proc));
          LOOPCRASH;
        }

      INF_DEBUG_LOG ("Task %ld test #%d: solution exit with exit_code %d, rss_usage %lld and time_usage %lld\n", __self->sid, i,
        RUN_PROC_EXITCODE (*proc), RUN_PROC_RSSUSAGE (*proc), RUN_PROC_TIMEUSAGE (*proc));

      // Overview solution's status
      if (RUN_PROC_MEMORYLIMIT      (*proc)) ERR (ML, "ML") else
      if (RUN_PROC_TIMELIMIT        (*proc)) ERR (TL, "TL") else
      if (PROCESS_RUNTIME_ERROR (*proc)) ERR (RE, "RE") else
        {
          if (!fexists (full_output))
            {
              // No output file. Presentation error.
              ERR (PE, "PE");
              INF_DEBUG_LOG ("Task %ld. Output file not found after running solution.", __self->sid);
            } else
            {
              ////
              // Exec checker
              SAFE_FREE_PROC (proc);
              INF_DEBUG_LOG ("Task %ld. Executing checker (cmd: %s)\n", __self->sid, checker_cmd);
              proc=run_create_process (checker_cmd, __cur_data_dir, checker_memory_limit, checker_time_limit);

              run_execute_process (proc);
              run_pwait (proc);
              INF_DEBUG_LOG ("Task %ld. Finish executing checker\n", __self->sid);

              LOOP_CHECK_ACTIVE;

              // Error while trying to execute checker
              if (RUN_PROC_EXEC_ERROR (*proc))
                {
                  INF_DEBUG_LOG ("Task %ld. Fatal error duting executing checker: %s\n", __self->sid, RUN_PROC_ERROR_DESC (*proc));
                  TASK_LOG (*__self, "\n--------\nFatal error: error executing checker "
                    "at test #%d: %s.\nTesting aborted.\n", i+1, RUN_PROC_ERROR_DESC (*proc));
                  REPORT (__params, "Error executing checker at test #%d: %s.",
                    i+1, RUN_PROC_ERROR_DESC (*proc));
                  LOOPCRASH;
                }


              // Cecker finished by signal.
              if (RUN_PROC_TERMINATED (*proc))
                {
                  TASK_LOG (*__self, "\n--------\nFatal error: Abnormal checker termionation"
                    "at test #%d. TERM signal: %d.\nTesting aborted.\n", i+1, RUN_PROC_TERMSIG (*proc));
                  REPORT (__params, "Abnormal checker termination at test #%d. TERM signal: %d.", i+1, RUN_PROC_TERMSIG (*proc));
                  LOOPCRASH;
                }

              INF_DEBUG_LOG ("Task %ld. Checker finished working with exit code %d\n", __self->sid, RUN_PROC_EXITCODE (*proc));

              // Resource usage error while executing checker
              if (RUN_PROC_MEMORYLIMIT (*proc) || RUN_PROC_TIMELIMIT (*proc))
                {
                  INF_DEBUG_LOG ("Task %ld. Checker's resource usage error (%s)\n", __self->sid, ((RUN_PROC_MEMORYLIMIT (*proc))?("Memory limit"):("Time limit")) );

#ifdef __DEBUG
                  if (RUN_PROC_MEMORYLIMIT (*proc))
                    INF_DEBUG_LOG ("Task %ld. Checker's memory limit was %lld but %lld was used\n", __self->sid, checker_memory_limit, RUN_PROC_RSSUSAGE (*proc)); else
                    INF_DEBUG_LOG ("Task %ld. Checker's time limit was %lld but %lld was used\n", __self->sid, checker_time_limit, RUN_PROC_TIMEUSAGE (*proc));
#endif

                  TASK_LOG (*__self, "\n--------\nFatal error: resource limit error while executing checker.\nTesting aborted.\n");
                  REPORT (__params, "Resource limit exceeded while executing checker at test #%d. ", i+1);
                  LOOPCRASH;
                }

              // Overview checker's exit code
              switch (RUN_PROC_EXITCODE (*proc))
                {
                  case _OK:
                    // Update points for task
                    (*__points)+=tests[i];
                    push_string ("OK", " ", tests_res_pchar);
                    break;
                  case _WA: ERR (WA, "WA"); break;
                  case _PE: ERR (PE, "PE"); break;
                  default:
                    // Unknown checker's exit code
                    TASK_LOG (*__self, "\n--------\nFatal error: checker exited with unknown code: %d.\n"
                      "Buffer from checker: %s\nTesting aborted.\n",
                      RUN_PROC_EXITCODE (*proc), RUN_PROC_PIPEBUF (*proc));
                    REPORT (__params, "Checker exited with unknown code: %d\n"
                      "Buffer from checker: %s", i+1, RUN_PROC_PIPEBUF (*proc));
                    LOOPCRASH;
                    break;
                }

              SAFE_FREE_PROC (proc);
           }
        }

      // Delete input file (to reduce storaging of garbage) and
      // correct handling of PE
      unlink (full_input);
      unlink (full_output);

      SAFE_FREE_PROC (proc);

      // Log information about passed test
      LOG_TEST;
    }

  INF_DEBUG_LOG ("Task %ld. Testing mainloop finished\n", __self->sid);

__done_:
  SAFE_FREE_PROC (proc);

  assarr_set_value (__params, "TESTS", strdup (tests_res_pchar));

  remove_chroot_data (__cur_testing_dir);

  LOOP_DONE_CHECK_ACTIVE;

  if (!CR)
    {
      if (RE) push_string ("RE", " ", __errors);
      if (ML) push_string ("ML", " ", __errors);
      if (TL) push_string ("TL", " ", __errors);
      if (WA) push_string ("WA", " ", __errors);
      if (PE) push_string ("PE", " ", __errors);

      //
      // If errors' string is empty, no errors were occured
      // in task's testing. So we can set bonus to points.
      if (!strcmp (__errors, ""))
        {
          (*__points)+=bonus;
          strcpy (__errors, "OK");
        }
    }
}

static void
set_output_params                  (wt_task_t *__task, assarr_t *__params)
{
  int i;
  char *pchar;
  flex_value_t *retprops=0;
  
  //
  // TODO:
  //  Need beautiful solution to solve this query
  //

  CONFIG_OPEN_KEY (retprops, "Server/Modules/Informatics/RetProps");
  if (!retprops) return;

  for (i=0; i<FLEXVAL_ARRAY_LENGTH (retprops); i++)
    {
      pchar=flexval_get_array_string (retprops, i);
      if (assarr_get_value (__params, pchar))
        TASK_SET_OUTPUT_PARAM (*__task, pchar, strdup (assarr_get_value (__params, pchar)));
    }
}

static void
print_common_info                  (wt_task_t *__self)
{
	TASK_LOG (*__self, "-- Common information:\n");
	TASK_LOG (*__self, "    Solution ID : %ld\n", __self->sid);
	TASK_LOG (*__self, "    Problem ID  : %s\n",  (char*)assarr_get_value (__self->input_params, "PROBLEMID"));
	TASK_LOG (*__self, "    Compiler ID : %s\n",  (char*)assarr_get_value (__self->input_params, "COMPILERID"));
	TASK_LOG (*__self, "    TESTS       : %s\n",  (char*)assarr_get_value (__self->input_params, "TESTS"));
	TASK_LOG (*__self, "\n");
}

static BOOL     // Checks for required input params
check_required_params              (wt_task_t *__self, char *__err)
{
  BOOL res=TRUE;
  int i=0;
  char *cur;
  
  // Initialization
  strcpy (__err, "");

  cur=required_params[i];
  while (cur)
    {
      if (!TASK_INPUT_PARAM (*__self, cur))
        {
          push_string (cur, ", ", __err);
          res=FALSE;
        }
      cur=required_params[++i];
    }

  return res;
}

static void     // Unlink all unwanted testing dirs
unlink_unwanted_testing_dirs       (void)
{
  static BOOL initialized=FALSE;
  static timeval_t last_unlink;
  timeval_t cur=now ();

  mutex_lock (unlink_mutex);
  INF_DEBUG_LOG ("Start unlinking unwanted dirs\n");

  if (!initialized)
    {
      last_unlink=now ();
      initialized=TRUE;
    }

  if (CHECK_TIME_DELTA (last_unlink, cur, unlink_interval))
    {
      char *cur_dir, full[4096];
      int to_delete=0;
      dynastruc_t *ls;

      ls=dir_listing (testing_dir);

      to_delete=dyna_length (ls)-keep_alive_testdirs;
      if (to_delete<0) to_delete=0;

      DYNA_FOREACH (ls, cur_dir);
        if (!to_delete) DYNA_BREAK;
        INF_INFO ("Unlink testing dir %s\n", cur_dir);
        sprintf (full, "%s/%s", testing_dir, cur_dir);
        unlinkdir (full);
        to_delete--;
      DYNA_DONE;

      dyna_destroy (ls, dyna_deleter_free_ref_data);
      last_unlink=cur;
    }

  mutex_unlock (unlink_mutex);
  INF_DEBUG_LOG ("Unwanted dirs have been just deleted\n");
}

static void     // Main testing thread
testing_thread                     (gpointer __data, gpointer __user_data)
{
  wt_task_t *task=__data;

  char pchar[65536];

  // Directories for current testing stuff
  char cur_testing_dir[4096];
  char cur_data_dir[4096];

  int points=0, rc;
  char errors[MAX_TESTS*(MAX_ERRCODE+1)];
  FILE *stream;

  assarr_t *all_params;


  TASK_SET_STATUS (*task, TS_RUNNING);  // Update status of the task

  INF_DEBUG_LOG ("Started new thread for testing task %ld\n", task->sid);

  all_params=assarr_create ();


  // Calculating current testing and data directories
  sprintf (cur_testing_dir, "%s/%ld",    testing_dir, task->sid);
  sprintf (cur_data_dir,    "%s/%s/%s",  data_dir,    problems_dir, (char*)TASK_INPUT_PARAM (*task, "PROBLEMID"));

  unlinkdir (cur_testing_dir);    // To delete all unwanted data

  // Create global testing root.
  // Deny reading of this root to deny getting listing of this catalogue to executable solutions.
  fmkdir (testing_dir, 00773);
  fmkdir (cur_testing_dir, 00777); // Create current testing directory

  // Some initialization
  points=0;
  strcpy (errors, "");

  // Start logging
  print_common_info (task);

  //
  // TODO:
  //  Add TASK_SET_RESULT_MESSAGE() in case of testing crash
  //

  INF_DEBUG_LOG ("Task %ld. Check for required parameters\n", task->sid);

  // Check for required data
  if (!check_required_params (task, pchar))
    {
      strcpy (errors, "CR");
      TASK_LOG (*task, "\n========\nFatal error: Required params aren't defined: %s! Testing aborted.\n", pchar);
      REPORT (all_params, "Required params aren't defined: %s.", pchar);
      goto __done_;
    }

  //////////////////////////////////////
  // TESTING STUFF

  ////////
  // Step 0: Saving solution source to file

  INF_DEBUG_LOG ("Task %ld. Step 0: Save solution\n", task->sid);

  if (!save_solution (task, cur_testing_dir))
    {
      strcpy (errors, "CR");
      TASK_LOG (*task, "\n========\nFatal error: unable to save solution! Testing aborted.\n");
      REPORT (all_params, "Error saving solution.");
      goto __done_;
    }

  ////////
  // Step 1: Compiling colution
  INF_DEBUG_LOG ("Task %ld. Step 1: Compile solution\n", task->sid);

  rc=compile_solution (task, cur_testing_dir, cur_data_dir, all_params);

  TESTING_CHECK_ACTIVE;

  if (rc<0) // Fatal errors while compile
    {
      INF_DEBUG_LOG ("[EE] Task %ld. Ctirical error during solution compilation process\n");
      points=0;
      strcpy (errors, "CR");
      TASK_LOG (*task, "\n========\nFatal error while compiling solution. Testing aborted.\n");
      goto __done_;
    }

  if (!rc) // Simple compilation error
    {
      points=0;
      strcpy (errors, "CE");
      goto __done_;
    }

  ////////
  // Step 2: Exec solution at all tests
  testing_main_loop (task, cur_data_dir, cur_testing_dir, &points, errors, all_params);

  TESTING_CHECK_ACTIVE;

__done_:

  // Updating avaliable parameters
  sprintf (pchar, "%d", points);
  assarr_set_value (all_params, "POINTS", strdup (pchar));
  assarr_set_value (all_params, "ERRORS", strdup (errors));

  // Set output parameters for WebInterface
  set_output_params (task, all_params);

  // Some uinitialization
  assarr_destroy (all_params, assarr_deleter_free_ref_data);

  ////
  //
  if (strcmp (errors, "OK"))
    sprintf (pchar, "Points: %d. Errors: %s", points, errors); else
    {
      int bonus=atoi (TASK_INPUT_PARAM (*task, "BONUS"));
      sprintf (pchar, "Points: %d. Bonus: %d", points-bonus, bonus);
    }
  TASK_SET_RESULT_MESSAGE (*task, pchar);

  if (strcmp (errors, "CE") && strcmp (errors, "CR"))
    TASK_LOG (*task, "\n========\nTesting completed: %s\n", pchar);

  // Save log
  sprintf (pchar, "%s/errors.log", cur_testing_dir);
  stream=fopen (pchar, "w");
  if (stream)
    {
      fprintf (stream, "%s", log_banner);
      TASK_LOG_FLUSH (*task, stream);
      fclose (stream);
    }
  chmod (pchar, 00660);

  INF_DEBUG_LOG ("Task %ld tested\n", task->sid);

  TASK_SET_STATUS (*task, TS_FINISHED); // Now task is completely tested

  goto __all_done_;

__free_:
  assarr_destroy (all_params, assarr_deleter_free_ref_data);
  TASK_SET_STATUS (*task, TS_INTERRUPTED);

__all_done_:
  unlink_unwanted_testing_dirs ();

  INF_DEBUG_LOG ("Leave testing thread\n");
}

///////////////////////////////////
// End-users's stuff

static void     // Read data from config file
read_config                        (void)
{
  double t=0;
  char dummy[1024];

  INF_INT_KEY (checker_memory_limit, "Checker/Limits/RSS"); 

  INF_FLOAT_KEY (t, "Checker/Limits/Time");
  checker_time_limit=t*USEC_COUNT;

  INF_INT_KEY (t, "MaxThreads");
  if (t>0) max_threads=t;

  INF_PCHAR_KEY (testing_dir,   "TestingDir");
  INF_PCHAR_KEY (data_dir,      "DataDir");
  INF_PCHAR_KEY (problems_dir,  "ProblemsDir");

  INF_SAFE_PCHAR_KEY (source_file,  "SourceFile", INFORMATICS_SOURCE);
  INF_SAFE_PCHAR_KEY (file_to_exec, "FileToExec", INFORMATICS_EXEC);

  // Tests' files extensions  
  INF_SAFE_PCHAR_KEY (tst_ext, "Tests/InputExtension",  INFORMATICS_TSTEXT);
  INF_SAFE_PCHAR_KEY (ans_ext, "Tests/OutputExtension", INFORMATICS_ANSEXT);

  INF_SAFE_PCHAR_KEY (checker_cmd_template, "Checker/Command", "");

  INF_INT_KEY (unlink_interval,     "UnlinkInterval");
  INF_INT_KEY (keep_alive_testdirs, "KeepAliveTestdirs");

  INF_PCHAR_KEY (dummy, "ChRoot");
  use_chroot=is_truth (dummy);

  ////
  // Get security info

  INF_SAFE_PCHAR_KEY (solution_exec_user, "SolutionExec-User", "");
  solution_exec_uid=uid_by_name (solution_exec_user);
  INF_SAFE_PCHAR_KEY (solution_exec_group, "SolutionExec-Group", "");
  solution_exec_gid=gid_by_name (solution_exec_group);
}

static void
create_testing_pool                (void)
{
  pool=g_thread_pool_new (testing_thread, NULL, max_threads, FALSE, NULL);
}

BOOL            // Initialize testing stuff
Informatics_init_testing           (void)
{
  read_config ();

  active       = mutex_create ();
  unlink_mutex = mutex_create ();
  suspended    = mutex_create ();

  create_testing_pool ();

  mutex_lock (active);

  return TRUE;
}

void            // Uninitialize testing stuff
Informatics_done_testing           (void)
{
  Informatics_stop_testing (0, 0);
  if (active)
    mutex_free (active);
  if (unlink_mutex)
    mutex_free (unlink_mutex);
  if (suspended)
    mutex_free (suspended);
  if (pool)
    g_thread_pool_free (pool, FALSE, FALSE);
}

int             // Wait for stopping all testing threads
Informatics_stop_testing           (void *__unused, void *__call_unused)
{
  if (!active || !pool)
    return -1;

  if (mutex_trylock (active))
    {
      mutex_unlock (active);
      return -1;
    }

  // IMHO it is the best way to wait for all threads is finished
  mutex_unlock (active);
  g_thread_pool_free (pool, FALSE, TRUE);
  create_testing_pool ();

  return 0;
}

BOOL            // Creates new testing thread
Informatics_start_testing_thread   (wt_task_t *__task, char *__error)
{

  // Try to lock `suspended` to make shure stuff is not suspended
  mutex_lock (suspended);
  // if locking is completed, unlock `suspended`
  mutex_unlock (suspended);

  if (mutex_trylock (active))
    {
      strcpy (__error, "Testing stuff is not active");
      mutex_unlock (active);
      return FALSE;
    }

  INF_DEBUG_LOG ("Staring testing thread for task %ld\n", __task->sid);

  if (g_thread_pool_get_num_threads (pool)>=max_threads)
    {
      INF_DEBUG_LOG ("Staring testing thread for task %ld failed: pool is full. Continue waiting in queue\n", __task->sid);
      strcpy (__error, "Testing pool is full");
      TASK_SET_FLAG (*__task, TF_KEEPINQUEUE);
      return FALSE;
    }

   INF_DEBUG_LOG ("Pushing testing thread for task %ld\n", __task->sid);
  g_thread_pool_push (pool, __task, 0);

  return TRUE;
}

int
Informatics_SuspendTesting         (void)
{
  mutex_lock (suspended);

  // It the simpliest way to free pool
  g_thread_pool_free (pool, FALSE, TRUE);
  create_testing_pool ();
  return 0;
}

int
Informatics_ResumeTesting         (void)
{
  mutex_unlock (suspended);
  return 0;
}
